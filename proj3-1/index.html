<html>
	<head>
		<style>
  			body {
    				padding: 100px;
    				width: 1000px;
    				margin: auto;
    				text-align: left;
    				font-weight: 300;
    				font-family: 'Open Sans', sans-serif;
    				color: #121212;
  			}
  			h1, h2, h3, h4 {
    				font-family: 'Source Sans Pro', sans-serif;
  			}
		</style>
		<title>CS 184 MeshEdit</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
	</head>
	
	<body>
		<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
		<h1 align="middle">Project 3: PathTracer</h1>
		<h2 align="middle">Riya Kumar and Mylinh Vu, CS184-rm</h2>

		<br><br>

		<div>

		<h2 align="middle">Overview</h2>
			<p></p>


		<h2 align="middle">Part I: Ray Generation and Scene Intersection</h2>
			Walk through the ray generation and primitive intersection parts of the rendering pipeline
			<p>To generate a camera ray, normalized coordinates need to be transformed into camera space. 
				From there, we can generate a ray in camera space that will be converted into a ray in world space. 
				With the ray, then we can determine what rays intersect either the pixel or shape. In this task, 
				we implemented triangle and sphere intersection.</p>
			<p>For triangle intersection, we utilized the Moller-Trumbore intersection algorithm. This algorithm 
				takes in the equations of the ray and the triangle and set them equal to each other. From there, 
				we calculated edges (e1 and e2) and spaces (s, s1, s2). With these values, we can find the arbitrary 
				values of t, b1, and b2 which will determine if the ray intersects the triangle. If b1 and b2 are 
				between 0 and 1 and 1 is within the range of the ray, then the ray intersected the triangle. </p>

		<div align="middle">
			<table style="width=100%">
			<tr>
				<td>
					<img src="banana.png" align="middle" width="400px"/>
					<figcaption align="middle">Generating Pixel Samples for Banana</figcaption>
				</td>
				<td>
					<img src="CBemptyGradient.png" align="middle" width="400px"/>
					<figcaption align="middle">Generating Pixel Samples for CBEmpty</figcaption>
				</td>
			</tr>
			<br>
			<tr>
				<td>
					<img src="CBempty.png" align="middle" width="400px"/>
					<figcaption align="middle">Rendering with Ray-Triangle Intersection</figcaption>
				</td>
				<td>
					<img src="CBspheres.png" align="middle" width="400px"/>
					<figcaption align="middle">Rendering with Ray-Sphere Intersection</figcaption>
				</td>
			</tr>
			<tr>
				<td>
					<img src="bananaRender.png" align="middle" width="400px"/>
					<figcaption align="middle">More Scene Rendering</figcaption>
				</td>
				<td>
					<img src="CBbunny.png" align="middle" width="400px"/>
					<figcaption align="middle">Bunny Rendering</figcaption>
				</td>
			</tr>	
			</table>
		</div>
			
		<h2 align="middle">Part 2: Bounding Volume Hierarchy</h2>
			<p> In order to construct the BVH, we find the number of primitives given to us. If there are less primitives
				than allowed for the max leaf size, we simply create a leaf node by specifying a new start and end for
				the node. The left and right values will be null since it is a leaf. However, if there are more primitves than
				the allowed for a leaf node, then we have to divide the leaf nodes into a right and left side and use recursion. 
				We find the average for all the primitives which will later use to compare against the centroids. We do this by creating
				a 0 vector in the x, y, and z direction and looping through all the primitives. We add each primitives' bbox's centroid to
				our average so it is representitive of all the primitives. We divide this sum by the number of primitives to get the average.
				Our next step is to figure out what axis to split on that gives us the most benefit.
				
				For each axis, we start by dividing all the primitives into the category of right or left based on how their centroid compares to our average centroid value for that axis that we calculated
				eariler. We then build each primitives bbox. We find the extent, or the difference between the max and min of each bbox. We use the extent
				to find the left hueristic and the right hueristic. We can sum these to find the overall hueristic. Since this new hueristic is made up of
				both the left and right sides, we can compare this against the overall smallest_surface_area_hueristic. The hueristic will be compared to the
				hueristic for all this axis so whichever is smallest of the axis will prevail. 
				
				So once we know which axis it is most benneficial to split on, we prepare for recursion. We set the left primitives and right primitives
				to those of the axis it is most benneficial to split on. We do that by iterating through all the primtiives, like in the previous step, only this
				time we are getting the bbox's centroid on the most benneficial axis and comparing it to the average of the most beneficial axis aswell. 
				
				Once that's done, we just need to find the proper iterators to pass into the recursive call. For left recursive call, we can use start, but then we need
				to create a center left iterator for the call to use as an end iterator. We do this by iterating through the  number of primitives and assigning values
				to the left and right iterators. For the right recursive call, we can start off at the left center iterator, but then we can use the end iterator. For both calls
				we can use the max_leaf_size that was given. After the recursion comes up with lists that are smaller than the max leaf size, we will get leaf nodes returned from the
				bottom up. 
				
			</p>
			
			<p>
				Here are some large .dae files that are too large to render without BVH.
			</p>
			
			<div align="middle">
			<table style="width=100%">
			<tr>
				<td>
					<img src="part2_image1.png" align="middle" width="400px"/>
					<figcaption align="middle">Complicated image with normal shading</figcaption>
				</td>
				<td>
					<img src="part2_image2.png" align="middle" width="400px"/>
					<figcaption align="middle">Complicated image with normal shading</figcaption>
				</td>
				<td>
					<img src="part2_image_3.png" align="middle" width="400px"/>
					<figcaption align="middle">Complicated image with normal shading</figcaption>
				</td>
			</tr>
		
		</table>
	</div>
	</body>
</html>
