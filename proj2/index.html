<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 MeshEdit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 2: MeshEdit</h1>
<h2 align="middle">Riya Kumar and Mylinh Vu, CS184-rm</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curved with 1D de Casteljau Subdivision</h3>
<p> Casteljau's algorithm takes the weighted average between 2 points in the base and repeatedly takes these averages until a single point is found. 
	This algorithm builds a curve with it's interpolated points which we call the Bezier curve. 
<p> For this task, we iterated through all adjacent points in the vector and took the weighted average of them. We did this by taking the difference 
	of the x and y values and weighted it by mutiplying by the t value. With each adjacent pair we added a point to a new vector. The returning 
	vector contains one less point than the starting vector which allows the process to be repeated until finding a point that lands on the Bezier curve. </p>

<div align="middle">
  <table style="width=100%">
    
    <tr>
      <td>
        <img src="my_base_points.png" align="middle" width="400px"/>
        <figcaption align="middle">Base points</figcaption>
      </td>
      <td>
        <img src="my_step1.png" align="middle" width="400px"/>
        <figcaption align="middle">After 1 Step of the Algorithm</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="my_step2.png" align="middle" width="400px"/>
        <figcaption align="middle">After 2 Steps of the Algorithm</figcaption>
      </td>
       <td>
        <img src="my_step3.png" align="middle" width="400px"/>
        <figcaption align="middle">After 3 Steps of the Algorithm</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="my_step4.png" align="middle" width="400px"/>
        <figcaption align="middle">After 4 Steps of the Algorithm</figcaption>
      </td>
      <td>
        <img src="my_step5.png" align="middle" width="400px"/>
        <figcaption align="middle">After 5 Steps of the Algorithm</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="my_withcurve.png" align="middle" width="400px"/>
        <figcaption align="middle">Calculated Points lands on Bezier Curve</figcaption>
      </td>
      <td>
        <img src="my_newpoint.png" align="middle" width="400px"/>
        <figcaption align="middle">Changing the t value is still on Curve</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="my_newcurve.png" align="middle" width="400px"/>
        <figcaption align="middle">Another example</figcaption>
      </td>
  </tr>
  </table>
</div>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau </h3>  
<p> With Bezier surfaces, it becomes a 3D process by taking weighted averages of 3D points and finding the Bezier curves in 2 dimensions. With the 2
	dimensional curves, you can use it to trace the surface. To implement this, similar to task 1, we use de Casteljau's algorithm to find the interpolated
	point, but using 3D dimensions so applying the same math to the z direction. However, we had 2 difference weighted values of u and v and found a set of
	interpolated points to create various curved in the u direction. Then, we interpolated the values in the v direction to be able to apply it into 
	a 3D surface. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="teapot_mesh.png" align="middle" width="400px"/>
        <figcaption align="middle">Mesh Rendering of Teapot</figcaption>
      </td>
    </tr>
  </table>
</div>
	

<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3> 
	Briefly explain how you implemented the area-weighted vertex normals.
<p> To get the area-weighted vertex normals, we iterated through the halfedges and found all the points in the corresponding triangle. By crossing the 
	half-edge vector and the next vector we find the normal that is added to the weighted normal. However, since the length of the vector creates
	problems, we must take the unit vector of it so produce the smooth image.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="flat_mesh.png" align="middle" width="400px"/>
        <figcaption align="middle">Default Flat Shading without Normals</figcaption>
      </td>
      <td>
        <img src="smooth_mesh.png" align="middle" width="400px"/>
        <figcaption align="middle">Phong Shading with Normals</figcaption>
      </td>
    </tr>
  </table>
</div>
	
	Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
Show screenshots of a mesh before and after some edge flips.
Write about your eventful debugging journey, if you have experienced one.

<h3 align="middle">Part 4: Edge Flip</h3>
	<p> We implemented the edge flip operation by first finding the halfedge associated with the edge iterator passed in, or the one the user clicks.
		Then we find the associated halfedges, edges, and vertices from the current triangle and the next triangle we are flipping the edge with by iterating around the triangles halfedges, edges, and twin edges.
		We then reset the neighbors, physically redrawing edges with their correct neighbors. Lastly, we reassign the 


<h3 align="middle">Part 5: Edge Splits</h3>
	
<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>

  
  <p> link to website </p>
  <p> https://rkumar06.github.io/proj-webpage-template/ </p>



<h2 align="middle">Section III: Optional, Possible Extra Credit</h2>

<h3 align="middle">Part 7: Design and Edit Your Own Mesh! (Optional, Possible Extra Credit)</h3>

</body>
</html>
